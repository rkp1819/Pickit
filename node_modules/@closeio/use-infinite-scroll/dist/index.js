'use strict';

var react = require('react');

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/**
 * An infinite scroller based on effects.
 * Every time the loader is `N`px to be shown, switch to a new page, load new items.
 *
 * @example
 * const [items, setItems] = useState([]);
 * const [hasMore, setHasMore] = useState(false);
 * const [page, loaderRef, scrollerRef] = useInfiniteScroll({ hasMore });
 *
 * useFetchEffect(async ({ signal }) => {
 *   const data = await myApiCall({ page }, { signal });
 *   setHasMore(data.hasMore);
 *   setItems(prev => [...prev, data.items]);
 * }, [page])
 *
 * return (
 *   <div ref={scrollerRef}>
 *     {items.map(item => <div key={item.id}>{item.name}</div>)}
 *     {hasMore && <div ref={loaderRef}>Loadingâ€¦</div>}
 *   </div>
 * );
 * @param {Object} [options={}]
 * @param {boolean} options.hasMore The observer will disconnect when there are no more items to load.
 * @param {boolean} [options.reset=false] Pass true when you're re-fetching the list and want to resets the scroller to page 0.
 * @param {number} [options.distance=250] When scrolling, the distance in pixels from the bottom to switch the page.
 */

function useInfiniteScroll(_ref) {
  var hasMore = _ref.hasMore,
      _ref$reset = _ref.reset,
      reset = _ref$reset === void 0 ? false : _ref$reset,
      _ref$distance = _ref.distance,
      distance = _ref$distance === void 0 ? 250 : _ref$distance;
  var scrollContainerRef = react.useRef();
  var loaderRef = react.useRef();

  var _useState = react.useState(0),
      _useState2 = _slicedToArray(_useState, 2),
      page = _useState2[0],
      setPage = _useState2[1];

  if (reset && page !== 0) {
    setPage(0);
  }

  react.useLayoutEffect(function () {
    var loaderNode = loaderRef.current;
    var scrollContainerNode = scrollContainerRef.current;
    if (!scrollContainerNode || !loaderNode || !hasMore) return;
    var options = {
      root: scrollContainerNode,
      rootMargin: "0px 0px ".concat(distance, "px 0px")
    };
    var previousY;
    var previousRatio = 0;

    var listener = function listener(entries) {
      entries.forEach(function (_ref2) {
        var isIntersecting = _ref2.isIntersecting,
            intersectionRatio = _ref2.intersectionRatio,
            _ref2$boundingClientR = _ref2.boundingClientRect,
            boundingClientRect = _ref2$boundingClientR === void 0 ? {} : _ref2$boundingClientR;
        var y = boundingClientRect.y;

        if (isIntersecting && intersectionRatio >= previousRatio && (!previousY || y < previousY)) {
          setPage(function (page) {
            return page + 1;
          });
        }

        previousY = y;
        previousRatio = intersectionRatio;
      });
    };

    var observer = new IntersectionObserver(listener, options);
    observer.observe(loaderNode);
    return function () {
      return observer.disconnect();
    };
  }, [hasMore, distance]);
  return [page, loaderRef, scrollContainerRef];
}

module.exports = useInfiniteScroll;
//# sourceMappingURL=index.js.map
